<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Royal Spark AI Tesseract</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1e0a33 0%, #000000 100%);
            color: #fff;
            font-family: 'Exo 2', sans-serif;
        }
        canvas {
            display: block;
        }
        #title-container {
            position: absolute;
            top: 30px;
            width: 100%;
            text-align: center;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
            background: linear-gradient(90deg, #a855f7, #60a5fa, #34d399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 25px rgba(168, 85, 247, 0.5);
            animation: pulse-glow 4s infinite alternate;
        }
        .link-container {
            position: absolute;
            z-index: 10;
            transform: translate(-50%, -50%);
            perspective: 1000px;
        }
        .tool-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 160px;
            height: 160px;
            padding: 10px;
            text-align: center;
            background: rgba(17, 24, 39, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 50%; /* This makes it a circle */
            text-decoration: none;
            color: #f9fafb;
            font-weight: 600;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            white-space: normal; /* Allow text to wrap */
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.2), inset 0 0 10px rgba(139, 92, 246, 0.3);
        }
        .tool-link:hover {
            transform: scale(1.1);
            background: rgba(139, 92, 246, 0.4);
            border-color: #a855f7;
            box-shadow: 0 0 40px rgba(139, 92, 246, 0.4);
            text-shadow: 0 0 10px #fff;
        }
        
        @keyframes pulse-glow {
            from { text-shadow: 0 0 15px rgba(168, 85, 247, 0.3); }
            to { text-shadow: 0 0 35px rgba(96, 165, 250, 0.6); }
        }
    </style>
</head>
<body>
    <div id="title-container">
        <h1>AI Tesseract</h1>
    </div>

    <!-- Links to your AI Tools -->
    <div id="link1" class="link-container">
        <a href="#" class="tool-link" onclick="loadTool('Acquisition Compass.html')">Acquisition Compass</a>
    </div>
    <div id="link2" class="link-container">
        <a href="#" class="tool-link" onclick="loadTool('Agenda AI (1).html')">Agenda AI</a>
    </div>
    <div id="link3" class="link-container">
        <a href="#" class="tool-link" onclick="loadTool('SparkLens.html')">SparkLens</a>
    </div>
    <div id="link4" class="link-container">
        <a href="#" class="tool-link" onclick="loadTool('mmc generator.html')">MMC Generator</a>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Basic Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 8; // Pulled camera back slightly

        // --- Post-processing for Glow Effect ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.8;
        bloomPass.radius = 0.6;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Starfield Particle System ---
        const starVertices = [];
        const starColors = [];
        const starColorTypes = [
            new THREE.Color(0xffffff), // White
            new THREE.Color(0xaad8ff), // Light Blue
            new THREE.Color(0xffc0a0)  // Red-Orange
        ];
        for (let i = 0; i < 15000; i++) {
            const x = THREE.MathUtils.randFloatSpread(300);
            const y = THREE.MathUtils.randFloatSpread(300);
            const z = THREE.MathUtils.randFloatSpread(300);
            starVertices.push(x, y, z);
            const color = starColorTypes[Math.floor(Math.random() * starColorTypes.length)];
            starColors.push(color.r, color.g, color.b);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // --- Meteors ---
        const meteorGeometry = new THREE.BufferGeometry();
        const meteorVertices = [];
        for (let i = 0; i < 20; i++) {
            meteorVertices.push(
                THREE.MathUtils.randFloatSpread(500),
                THREE.MathUtils.randFloat(300, 400),
                THREE.MathUtils.randFloat(-300, -100)
            );
        }
        meteorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(meteorVertices, 3));
        const meteorMaterial = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.3, transparent: true,
            blending: THREE.AdditiveBlending, depthWrite: false
        });
        const meteors = new THREE.Points(meteorGeometry, meteorMaterial);
        scene.add(meteors);

        // --- Spaceships ---
        const spaceships = new THREE.Group();
        const shipGeometry = new THREE.ConeGeometry(0.05, 0.25, 8);
        const shipMaterial = new THREE.MeshBasicMaterial({ color: 0x9ca3af });
        for (let i = 0; i < 15; i++) {
            const ship = new THREE.Mesh(shipGeometry, shipMaterial);
            ship.position.set(
                THREE.MathUtils.randFloatSpread(80),
                THREE.MathUtils.randFloatSpread(80),
                THREE.MathUtils.randFloatSpread(40) - 40
            );
            ship.rotation.x = Math.PI / 2;
            ship.velocity = new THREE.Vector3(0, 0, THREE.MathUtils.randFloat(0.05, 0.15));
            spaceships.add(ship);
        }
        scene.add(spaceships);


        // --- Tesseract Geometry ---
        const points4D = [];
        for (let i = 0; i < 16; i++) {
            points4D.push(new THREE.Vector4(
                (i & 1) ? -1 : 1, (i & 2) ? -1 : 1,
                (i & 4) ? -1 : 1, (i & 8) ? -1 : 1
            ));
        }
        const edges = [
            0, 1, 0, 2, 0, 4, 0, 8, 1, 3, 1, 5, 1, 9, 2, 3, 2, 6, 2, 10,
            3, 7, 3, 11, 4, 5, 4, 6, 4, 12, 5, 7, 5, 13, 6, 7, 6, 14,
            7, 15, 8, 9, 8, 10, 8, 12, 9, 11, 9, 13, 10, 11, 10, 14,
            11, 15, 12, 13, 12, 14, 13, 15, 14, 15
        ];

        // --- Create Tesseracts ---
        function createTesseract(color, scale, linewidth) {
            const material = new THREE.LineBasicMaterial({ color: color, linewidth: linewidth });
            const tesseractGroup = new THREE.Group();
            tesseractGroup.scale.set(scale, scale, scale);
            tesseractGroup.children.material = material; 
            scene.add(tesseractGroup);
            return tesseractGroup;
        }

        const tesseract1 = createTesseract(0xa855f7, 2.5, 2);
        const tesseract2 = createTesseract(0x3b82f6, 2.8, 1);
        
        // --- Glowing Vertex Particles ---
        const particleTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.4, map: particleTexture,
            blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
        });
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(16 * 3);
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const vertexParticles = new THREE.Points(particleGeometry, particleMaterial);
        tesseract1.add(vertexParticles);

        // --- Mouse Controls ---
        let mouseX = 0, mouseY = 0;
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        }, false);

        // --- Animation Loop ---
        function projectAndDraw(tesseractGroup, angle4D) {
            const projectedPoints3D = [];
            points4D.forEach(p4 => {
                const p = p4.clone();
                const rotationXY = angle4D;
                const rotationZW = angle4D * 0.4;
                
                let x = p.x * Math.cos(rotationXY) - p.y * Math.sin(rotationXY);
                let y = p.x * Math.sin(rotationXY) + p.y * Math.cos(rotationXY);
                p.x = x; p.y = y;
                
                let z = p.z * Math.cos(rotationZW) - p.w * Math.sin(rotationZW);
                let w = p.z * Math.sin(rotationZW) + p.w * Math.cos(rotationZW);
                p.z = z; p.w = w;

                const distance = 4;
                const w_proj = 1 / (distance - p.w);
                projectedPoints3D.push(new THREE.Vector3(p.x * w_proj, p.y * w_proj, p.z * w_proj));
            });

            const lines = tesseractGroup.children.filter(c => c.isLine);
            if (lines.length === 0) {
                 for (let i = 0; i < edges.length; i += 2) {
                    const geometry = new THREE.BufferGeometry();
                    const line = new THREE.Line(geometry, tesseractGroup.children.material);
                    tesseractGroup.add(line);
                }
            }
            
            tesseractGroup.children.filter(c => c.isLine).forEach((line, i) => {
                 line.geometry.setFromPoints([
                    projectedPoints3D[edges[i*2]],
                    projectedPoints3D[edges[i*2 + 1]]
                ]);
            });

            if (tesseractGroup === tesseract1) {
                const positions = vertexParticles.geometry.attributes.position.array;
                for (let i = 0; i < 16; i++) {
                    positions[i * 3] = projectedPoints3D[i].x;
                    positions[i * 3 + 1] = projectedPoints3D[i].y;
                    positions[i * 3 + 2] = projectedPoints3D[i].z;
                }
                vertexParticles.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        const links = [
            { el: document.getElementById('link1'), x: 20, y: 25, speed: 0.2, amp: 2 },
            { el: document.getElementById('link2'), x: 80, y: 25, speed: 0.25, amp: 2.5 },
            { el: document.getElementById('link3'), x: 20, y: 75, speed: 0.15, amp: 3 },
            { el: document.getElementById('link4'), x: 80, y: 75, speed: 0.3, amp: 2 }
        ];

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            projectAndDraw(tesseract1, time * 0.5);
            projectAndDraw(tesseract2, time * 0.3);

            const targetRotationX = mouseY * 0.0005;
            const targetRotationY = mouseX * 0.0005;
            
            const rotationGroup = scene;
            rotationGroup.rotation.x += 0.05 * (targetRotationX - rotationGroup.rotation.x);
            rotationGroup.rotation.y += 0.05 * (targetRotationY - rotationGroup.rotation.y);

            stars.rotation.y += delta * 0.005;

            // Animate Meteors
            meteorGeometry.attributes.position.array.forEach((val, i) => {
                if (i % 3 === 1) { // y-coordinate
                    meteorGeometry.attributes.position.array[i] -= 2;
                    if (meteorGeometry.attributes.position.array[i] < -200) {
                        meteorGeometry.attributes.position.array[i] = 200;
                    }
                }
            });
            meteorGeometry.attributes.position.needsUpdate = true;

            // Animate Spaceships
            spaceships.children.forEach(ship => {
                ship.position.add(ship.velocity);
                if (ship.position.z > 50) {
                    ship.position.z = -50;
                    ship.position.x = THREE.MathUtils.randFloatSpread(80);
                    ship.position.y = THREE.MathUtils.randFloatSpread(80);
                }
            });
            
            links.forEach((link, i) => {
                const newX = link.x + Math.sin(time * link.speed + i) * link.amp;
                const newY = link.y + Math.cos(time * link.speed * 0.7 + i) * link.amp;
                link.el.style.left = `${newX}%`;
                link.el.style.top = `${newY}%`;
            });

            composer.render();
        }

        // --- Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }, false);
        
        // --- Link Loading Function ---
        window.loadTool = function(toolName) {
            alert(`Loading tool: ${toolName}`);
        }

        animate();
    </script>
</body>
</html>
